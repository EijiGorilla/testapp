"use strict";(self.webpackChunktestapp=self.webpackChunktestapp||[]).push([[89646],{89646:(e,t,r)=>{r.d(t,{$h:()=>p,Ef:()=>C,IP:()=>R,P1:()=>z,hF:()=>q,jQ:()=>w,rT:()=>S,rZ:()=>n,uR:()=>b});var n,i,a=r(73582),l=r(24648),o=r(31633),c=r(19555),s=r(72745),u=r(20664),g=r(9392),v=r(14487),f=r(7137),d=r(80963);function p(e,t){if(null==e||null==t)return;const r=h(e,t);return null!=r?(0,l.Wq)(r,"radians","geographic"):void 0}(i=n||(n={})).Absolute="absolute",i.Relative="relative",i.RelativeBilateral="relative-bilateral";const h=(()=>{const e=(0,g.vt)(),t=(0,g.vt)();return(r,n)=>((0,u.i)(e,r.x,r.y,r.z??0),(0,u.i)(t,n.x,n.y,n.z??0),R(e,t,r.spatialReference,n.spatialReference))})(),R=(()=>{const e=(0,s.vt)(),t=(0,g.vt)(),r=(0,g.vt)();return(n,i,a,l)=>{if((0,u.p)(n,i))return;const g=(0,f.geodesicCompatibleSpatialReference)(a),p=(0,f.geodesicCompatibleSpatialReference)(l);if(g&&p&&(0,d.aI)(g,p)&&(0,v.F)(n,a,t,g)&&(0,v.F)(i,l,r,p)){const{azimuth:e}=(0,f.inverseGeodeticSolver)(W,t,r,g);return null!=e?(0,o.oU)(e,"degrees","radians"):void 0}e[0]=i[0]-n[0],e[1]=i[1]-n[1];let h=(0,c.g7)(s.JP,e);return e[0]<0&&(h=k-h),h}})();function b(e,t,r){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n.Absolute;if(t&&r)switch(i){case n.Absolute:return p(t,r);case n.Relative:return w(m(e,t,r),n.Relative);case n.RelativeBilateral:return w(m(e,t,r),n.RelativeBilateral)}}function m(e,t,r){if(!e||!t||!r)return;const n=h(e,t),i=h(t,r);return null!=n&&null!=i?(0,l.Wq)(i-n,"radians","geographic"):void 0}function w(e,t){if(null!=e)switch(t){case n.Absolute:return z(e);case n.Relative:{const t=q(e);let r=A.normalize(t,0,!0);return-180===r&&(r=180),(0,l.Wq)(r,"degrees","geographic")}case n.RelativeBilateral:{const t=q(e),r=Math.abs(A.normalize(t,0,!0));return(0,l.Wq)(r,"degrees","geographic")}}}function z(e){const t=q(e),r=y.normalize(t,0,!0);return(0,l.Wq)(r,"degrees","geographic")}const S=(()=>{const e=(0,g.vt)();return function(t,r,n,i,a){let c=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"geodesic";(0,u.c)(e,r);const s=q(a);if("geodesic"===c){const a=(0,f.geodesicCompatibleSpatialReference)(n);if(a&&(0,v.F)(e,n,e,a))return(0,f.directGeodeticSolver)(t,e,s,i,a),t[2]=r[2],!!(0,v.F)(t,a,t,n)}const g=(0,l.g2)(s,"geographic","arithmetic"),d=(0,o.oU)(g,"degrees","radians"),p=r[0]+i*Math.cos(d),h=r[1]+i*Math.sin(d),R=r[2];return(0,u.i)(t,p,h,R),!0}})();function q(e){if(null!=e)return(0,l.g2)(F(e),e.rotationType,"geographic")}function C(e){if(null!=e)return(0,l.g2)(F(e),e.rotationType,"arithmetic")}function F(e){return(0,o.oU)(e.value,e.unit,"degrees")}const W=new f.InverseGeodeticSolverResult,k=2*Math.PI,y=a.ie,A=new a.hr(-180,180)}}]);
//# sourceMappingURL=89646.e138fd62.chunk.js.map