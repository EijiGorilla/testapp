"use strict";(self.webpackChunktestapp=self.webpackChunktestapp||[]).push([[56203],{56203:(e,n,t)=>{t.r(n),t.d(n,{buffer:()=>z,changeDefaultSpatialReferenceTolerance:()=>Z,clearDefaultSpatialReferenceTolerance:()=>$,clip:()=>d,contains:()=>h,convexHull:()=>b,crosses:()=>g,cut:()=>w,densify:()=>F,difference:()=>k,disjoint:()=>O,distance:()=>m,equals:()=>S,extendedSpatialReferenceInfo:()=>y,flipHorizontal:()=>B,flipVertical:()=>G,generalize:()=>W,geodesicArea:()=>U,geodesicBuffer:()=>C,geodesicDensify:()=>K,geodesicLength:()=>X,intersect:()=>T,intersectLinesToPoints:()=>Y,intersects:()=>R,isSimple:()=>N,nearestCoordinate:()=>H,nearestVertex:()=>I,nearestVertices:()=>P,offset:()=>E,overlaps:()=>v,planarArea:()=>M,planarLength:()=>Q,relate:()=>J,rotate:()=>q,simplify:()=>D,symmetricDifference:()=>L,touches:()=>x,union:()=>V,within:()=>A});var r=t(16783),a=t(19247),i=t(19902);function c(e){return Array.isArray(e)?e[0]?.spatialReference:e?.spatialReference}function o(e){return e?Array.isArray(e)?e.map(o):e.toJSON?e.toJSON():e:e}function u(e){return Array.isArray(e)?e.map((e=>(0,i.fromJSON)(e))):(0,i.fromJSON)(e)}let s;async function f(){return s||(s=(0,r.ho)("geometryEngineWorker",{strategy:"distributed"})),s}async function l(e,n){return(await f()).invoke("executeGEOperation",{operation:e,parameters:o(n)})}async function p(e,n){const t=await f();return Promise.all(t.broadcast("executeGEOperation",{operation:e,parameters:o(n)}))}function y(e){return l("extendedSpatialReferenceInfo",[e])}async function d(e,n){return u(await l("clip",[c(e),e,n]))}async function w(e,n){return u(await l("cut",[c(e),e,n]))}function h(e,n){return l("contains",[c(e),e,n])}function g(e,n){return l("crosses",[c(e),e,n])}function m(e,n,t){return l("distance",[c(e),e,n,t])}function S(e,n){return l("equals",[c(e),e,n])}function R(e,n){return l("intersects",[c(e),e,n])}function x(e,n){return l("touches",[c(e),e,n])}function A(e,n){return l("within",[c(e),e,n])}function O(e,n){return l("disjoint",[c(e),e,n])}function v(e,n){return l("overlaps",[c(e),e,n])}function J(e,n,t){return l("relate",[c(e),e,n,t])}function N(e){return l("isSimple",[c(e),e])}async function D(e){return u(await l("simplify",[c(e),e]))}async function b(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return u(await l("convexHull",[c(e),e,n]))}async function k(e,n){return u(await l("difference",[c(e),e,n]))}async function L(e,n){return u(await l("symmetricDifference",[c(e),e,n]))}async function T(e,n){return u(await l("intersect",[c(e),e,n]))}async function V(e){const n=function(e,n){let t;return Array.isArray(e)?t=e:(t=[],t.push(e),null!=n&&t.push(n)),t}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:null);return u(await l("union",[c(n),n]))}async function E(e,n,t,r,a,i){return u(await l("offset",[c(e),e,n,t,r,a,i]))}async function z(e,n,t){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=[c(e),e,n,t,r];return u(await l("buffer",a))}async function C(e,n,t,r,a,i){const o=[c(e),e,n,t,r,a,i];return u(await l("geodesicBuffer",o))}async function H(e,n){let t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=await l("nearestCoordinate",[c(e),e,n,t]);return{...r,coordinate:a.default.fromJSON(r.coordinate)}}async function I(e,n){const t=await l("nearestVertex",[c(e),e,n]);return{...t,coordinate:a.default.fromJSON(t.coordinate)}}async function P(e,n,t,r){return(await l("nearestVertices",[c(e),e,n,t,r])).map((e=>({...e,coordinate:a.default.fromJSON(e.coordinate)})))}function j(e){return"xmin"in e?e.center:"x"in e?e:e.extent?.center}async function q(e,n,t){if(null==e)throw new _;const r=e.spatialReference;if(null==(t=t??j(e)))throw new _;const a=e.constructor.fromJSON(await l("rotate",[r,e,n,t]));return a.spatialReference=r,a}async function B(e,n){if(null==e)throw new _;const t=e.spatialReference;if(null==(n=n??j(e)))throw new _;const r=e.constructor.fromJSON(await l("flipHorizontal",[t,e,n]));return r.spatialReference=t,r}async function G(e,n){if(null==e)throw new _;const t=e.spatialReference;if(null==(n=n??j(e)))throw new _;const r=e.constructor.fromJSON(await l("flipVertical",[t,e,n]));return r.spatialReference=t,r}async function W(e,n,t,r){return u(await l("generalize",[c(e),e,n,t,r]))}async function F(e,n,t){return u(await l("densify",[c(e),e,n,t]))}async function K(e,n,t){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;return u(await l("geodesicDensify",[c(e),e,n,t,r]))}function M(e,n){return l("planarArea",[c(e),e,n])}function Q(e,n){return l("planarLength",[c(e),e,n])}function U(e,n,t){return l("geodesicArea",[c(e),e,n,t])}function X(e,n,t){return l("geodesicLength",[c(e),e,n,t])}async function Y(e,n){return u(await l("intersectLinesToPoints",[c(e),e,n]))}async function Z(e,n){await p("changeDefaultSpatialReferenceTolerance",[e,n])}async function $(e){await p("clearDefaultSpatialReferenceTolerance",[e])}class _ extends Error{constructor(){super("Illegal Argument Exception")}}}}]);
//# sourceMappingURL=56203.2307c7f8.chunk.js.map