"use strict";(self.webpackChunktestapp=self.webpackChunktestapp||[]).push([[10033,43277],{10033:(e,t,s)=>{s.r(t),s.d(t,{createVersioningStates:()=>l,getVersioningStates:()=>v});var i=s(19276),r=s(54901),n=s(76460),o=s(87663),a=s(8163),c=s(43277),u=s(54265),h=s(85056);async function l(e,t){let s;if("layers"in e){const t=(0,h.createVersionAdapters)(e.allTables.concat(e.allLayers).filter((e=>"group"!==e.type)).toArray());e.utilityNetworks&&e.utilityNetworks.forEach((e=>{const s=(0,h.createVersionAdapters)([e]);t.push(...s)})),s=t}else s=new i.default(e);const r=new Map;for(const o of s){const e=r.get(o.featureServiceUrl);e?e.push(o):r.set(o.featureServiceUrl,new i.default([o]))}const n=new i.default;for(const[i,o]of r){const e=new a.default({url:i});if(await e.load(),!e.versionManagementServiceUrl)continue;const s=new u.default({url:e.versionManagementServiceUrl});n.push(new c.default({versionManagementService:s,versionableItems:o,usePersistentReadSessions:t}))}return n}const d=new Map;async function v(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const s=await l(e.map,t);return(0,o.tE)(d,e,(()=>(e.addHandles((0,r.hA)((()=>{d.delete(e),s.forEach((e=>e.destroy()))}))),s.forEach((e=>e.load().catch((e=>{n.A.getLogger("esri.versionManagement.VersioningState").error("Failed to load Versioning State",e)})))),s)))}},43277:(e,t,s)=>{s.r(t),s.d(t,{default:()=>d});var i=s(35143),r=s(19276),n=s(50076),o=s(42553),a=s(49304),c=s(76460),u=s(46053),h=(s(81806),s(47249),s(85842));let l=class extends(o.A.JSONSupportMixin(a.A)){constructor(e){super(e),this.versionManagementService=null,this.featureServiceUrl=null,this.url=null,this.currentVersion=null,this.currentVersionInfo=null,this.versionInfos=[],this.versionableItems=new r.default,this.usePersistentReadSessions=!1,this.state="lock-none"}initialize(){this.url=this.versionManagementService.url,this.featureServiceUrl=this.url.replace(/\/VersionManagementServer/i,"/FeatureServer"),this.addHandles([this.versionableItems.on("before-add",(e=>{if(e.item.featureServiceUrl.toLowerCase()!==this.featureServiceUrl.toLowerCase())return e.preventDefault(),void c.A.getLogger(this).error("#add()","Cannot add versionAdapter, feature service urls do not match.")})),this.versionableItems.on("before-remove",(e=>{if(0===this.versionableItems.items.length&&this.currentVersion&&"name"in this.currentVersion&&"none"!==this.versionManagementService.getLockType(this.currentVersion))return e.preventDefault(),void c.A.getLogger(this).error("#remove()","Cannot remove last versionAdapter.")}))])}load(e){return this.addResolvingPromise(this._setUpState(e)),Promise.resolve(this)}get defaultVersionIdentifier(){return this.versionManagementService.defaultVersionIdentifier}get isDefault(){return!this.currentVersion||!!this.currentVersion&&"name"in this.currentVersion&&this.currentVersion.name===this.defaultVersionIdentifier.name}async getVersionInfos(){return arguments.length>0&&void 0!==arguments[0]&&arguments[0]&&(this.versionInfos=await this.versionManagementService.getVersionInfos()),this.versionInfos}async alterVersion(e,t){if(this.currentVersion&&"guid"in this.currentVersion&&e.guid===this.currentVersion.guid)return!1;const s=await this.versionManagementService.alterVersion(e,t);return s&&await this.getVersionInfos(!0),s}async deleteVersion(e){if(this.currentVersion&&"guid"in this.currentVersion&&e.guid===this.currentVersion.guid)return!1;const t=await this.versionManagementService.deleteVersion(e);return t&&await this.getVersionInfos(!0),t}async getVersionInfoExtended(){return this.currentVersion&&"name"in this.currentVersion?this.versionManagementService.getVersionInfoExtended(this.currentVersion):this.versionManagementService.getVersionInfoExtended(this.defaultVersionIdentifier)}async startEditing(){if(this._isDefaultOrHistoricVersion())return{success:!1};if(!this.usePersistentReadSessions){const e=await this.versionManagementService.startReadingWithResult(this.currentVersion);if(!e.success)return e;this.state="lock-read"}const e=await this.versionManagementService.startEditingWithResult(this.currentVersion);return e.success&&(this.state="lock-write"),e}async stopEditing(e){if(this._isDefaultOrHistoricVersion())return{success:!1};const t=await this.versionManagementService.stopEditingWithResult(this.currentVersion,e);if(!t.success)return t;if(this.state="lock-read",!this.usePersistentReadSessions){const e=await this.versionManagementService.stopReadingWithResult(this.currentVersion);return e.success&&(this.state="lock-none"),e}return t}async changeVersion(e){let t=null;if(this.usePersistentReadSessions){if(this._isDefaultOrHistoricVersion(e))e&&"name"in e?(t=await this.versionManagementService.getVersionInfoExtended(e),this.state="public"===t?.access?"lock-none":"lock-read"):this.state="lock-read";else if(!await this.versionManagementService.startReading(e))throw new n.default("Failed to acquire read lock for version: "+e);this._isDefaultOrHistoricVersion(this.currentVersion)||await this.versionManagementService.stopReading(this.currentVersion)}const s=await this.versionManagementService.changeVersionWithResult(this.versionableItems,this.currentVersion,e);let i=!1;return s.forEach(((e,t)=>{i=i||e.success})),i&&(this.currentVersion=e,this.currentVersionInfo=t||await this.getVersionInfoExtended(),this._isDefaultOrHistoricVersion()?this.currentVersion&&"name"in this.currentVersion?this.state="public"===this.currentVersionInfo?.access?"lock-none":"lock-read":this.state="lock-read":this.state="read"!==this.versionManagementService.getLockType(this.currentVersion)?"lock-none":"lock-read"),s}async undo(){return this._isDefaultOrHistoricVersion()?{success:!1}:(this.versionManagementService.undo(this.currentVersion),{success:!0})}async redo(){return this._isDefaultOrHistoricVersion()?{success:!1}:(this.versionManagementService.redo(this.currentVersion),{success:!0})}async _setUpState(e){await this.versionManagementService.load(e),this.state="lock-none",this.currentVersionInfo=await this.getVersionInfoExtended(),this.versionableItems.forEach((e=>{this.currentVersion?"name"in this.currentVersion?(e.gdbVersion=this.currentVersion.name,e.historicMoment=null):(e.historicMoment=this.currentVersion,e.gdbVersion=null):(e.gdbVersion=null,e.historicMoment=null)})),this.usePersistentReadSessions&&(this._isDefaultOrHistoricVersion()?this.currentVersion&&"name"in this.currentVersion?this.state="public"===this.currentVersionInfo?.access?"lock-none":"lock-read":this.state="lock-read":await this.versionManagementService.startReading(this.currentVersion)&&(this.state="lock-read"))}_isDefaultOrHistoricVersion(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.currentVersion;return!(e&&"name"in e)||e.name===this.versionManagementService.defaultVersionIdentifier.name}};(0,i._)([(0,u.MZ)()],l.prototype,"versionManagementService",void 0),(0,i._)([(0,u.MZ)()],l.prototype,"featureServiceUrl",void 0),(0,i._)([(0,u.MZ)()],l.prototype,"url",void 0),(0,i._)([(0,u.MZ)()],l.prototype,"currentVersion",void 0),(0,i._)([(0,u.MZ)()],l.prototype,"currentVersionInfo",void 0),(0,i._)([(0,u.MZ)()],l.prototype,"versionInfos",void 0),(0,i._)([(0,u.MZ)()],l.prototype,"versionableItems",void 0),(0,i._)([(0,u.MZ)()],l.prototype,"usePersistentReadSessions",void 0),(0,i._)([(0,u.MZ)()],l.prototype,"state",void 0),(0,i._)([(0,u.MZ)({readOnly:!0})],l.prototype,"defaultVersionIdentifier",null),(0,i._)([(0,u.MZ)({readOnly:!0})],l.prototype,"isDefault",null),l=(0,i._)([(0,h.$)("esri.versionManagement.VersioningState")],l);const d=l}}]);
//# sourceMappingURL=10033.0927ebde.chunk.js.map