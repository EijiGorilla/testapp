{"version":3,"file":"static/js/19637.9f1b2354.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/components/calcite-autocomplete/customElement.js","../node_modules/lit-html/src/directives/repeat.ts"],"sourcesContent":["import { c as I } from \"../../chunks/runtime.js\";\nimport { ref as h } from \"lit-html/directives/ref.js\";\nimport { repeat as y } from \"lit-html/directives/repeat.js\";\nimport { nothing as s, html as d } from \"lit\";\nimport { LitElement as $, createEvent as c, stringOrBoolean as m, safeClassMap as r } from \"@arcgis/lumina\";\nimport { useWatchAttributes as C } from \"@arcgis/components-controllers\";\nimport { debounce as k, escapeRegExp as A } from \"lodash-es\";\nimport { b as f, r as T, c as p, a as E, F as g } from \"../../chunks/floating-ui.js\";\nimport { u as w, I as O } from \"../../chunks/interactive.js\";\nimport { o as S } from \"../../chunks/openCloseComponent.js\";\nimport { c as F, d as D } from \"../../chunks/label.js\";\nimport { c as z, a as V, d as H, s as P, H as B } from \"../../chunks/form.js\";\nimport { a as b } from \"../../chunks/dom.js\";\nimport { g as M } from \"../../chunks/guid.js\";\nimport { u as L } from \"../../chunks/useT9n.js\";\nimport { V as U } from \"../../chunks/Validation.js\";\nimport { c as v } from \"../../chunks/observers.js\";\nimport { css as R } from \"@lit/reactive-element/css-tag.js\";\n/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\nv3.1.0 */\nconst G = R`:host([disabled]){cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}:host([disabled]) *,:host([disabled]) ::slotted(*){pointer-events:none}:host{position:relative;display:block}.input-container{position:relative;display:flex;flex:1 1 auto;flex-wrap:nowrap}.input{width:100%;--calcite-input-prefix-size: var(--calcite-autocomplete-input-prefix-size);--calcite-input-suffix-size: var(--calcite-autocomplete-input-suffix-size);--calcite-input-background-color: var(--calcite-autocomplete-input-background-color);--calcite-input-border-color: var(--calcite-autocomplete-input-border-color);--calcite-input-corner-radius: var(--calcite-autocomplete-input-corner-radius);--calcite-input-shadow: var(--calcite-autocomplete-input-shadow);--calcite-input-icon-color: var(--calcite-autocomplete-input-icon-color);--calcite-input-text-color: var(--calcite-autocomplete-input-text-color);--calcite-input-placeholder-text-color: var(--calcite-autocomplete-input-placeholder-text-color);--calcite-input-actions-background-color: var(--calcite-autocomplete-input-actions-background-color);--calcite-input-actions-background-color-hover: var(--calcite-autocomplete-input-actions-background-color-hover);--calcite-input-actions-background-color-press: var(--calcite-autocomplete-input-actions-background-color-press);--calcite-input-actions-icon-color: var(--calcite-autocomplete-input-actions-icon-color);--calcite-input-actions-icon-color-hover: var(--calcite-autocomplete-input-actions-icon-color-hover);--calcite-input-actions-icon-color-press: var(--calcite-autocomplete-input-actions-icon-color-press);--calcite-input-loading-background-color: var(--calcite-autocomplete-input-loading-background-color);--calcite-input-loading-fill-color: var(--calcite-autocomplete-input-loading-fill-color);--calcite-input-prefix-background-color: var(--calcite-autocomplete-input-prefix-background-color);--calcite-input-prefix-text-color: var(--calcite-autocomplete-input-prefix-text-color);--calcite-input-suffix-background-color: var(--calcite-autocomplete-input-suffix-background-color);--calcite-input-suffix-text-color: var(--calcite-autocomplete-input-suffix-text-color)}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}.interaction-container{display:contents}.content-container{box-sizing:border-box;width:100%}.floating-ui-container{--calcite-floating-ui-z-index: var(--calcite-z-index-dropdown);inline-size:max-content;display:none;max-inline-size:100vw;max-block-size:100vh;inset-block-start:0;left:0;z-index:var(--calcite-floating-ui-z-index)}.floating-ui-container .calcite-floating-ui-anim{position:relative;transition:var(--calcite-floating-ui-transition);transition-property:inset,left,opacity;opacity:0;box-shadow:0 0 16px #00000029;z-index:var(--calcite-z-index);border-radius:.25rem}.floating-ui-container[data-placement^=bottom] .calcite-floating-ui-anim{inset-block-start:-5px}.floating-ui-container[data-placement^=top] .calcite-floating-ui-anim{inset-block-start:5px}.floating-ui-container[data-placement^=left] .calcite-floating-ui-anim{left:5px}.floating-ui-container[data-placement^=right] .calcite-floating-ui-anim{left:-5px}.floating-ui-container[data-placement] .calcite-floating-ui-anim--active{opacity:1;inset-block-start:0;left:0}.content-container .calcite-floating-ui-anim{max-height:45vh;width:100%;overflow-y:auto;color:var(--calcite-autocomplete-text-color, var(--calcite-color-text-1));background-color:var(--calcite-autocomplete-background-color, var(--calcite-color-foreground-1));border-radius:var(--calcite-autocomplete-corner-radius, var(--calcite-corner-radius-round))}.content--hidden{display:none}@media (forced-colors: active){.floating-ui-container--active{border:1px solid canvasText}}.screen-readers-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border-width:0}.validation-container{display:flex;flex-direction:column;align-items:flex-start;align-self:stretch}:host([scale=m]) .validation-container,:host([scale=l]) .validation-container{padding-block-start:.5rem}:host([scale=s]) .validation-container{padding-block-start:.25rem}::slotted(input[slot=hidden-form-input]){margin:0!important;opacity:0!important;outline:none!important;padding:0!important;position:absolute!important;inset:0!important;transform:none!important;-webkit-appearance:none!important;z-index:-1!important}:host([hidden]){display:none}[hidden]{display:none}`, x = {\n  contentBottom: \"content-bottom\",\n  contentTop: \"content-top\"\n}, l = {\n  inputContainer: \"input-container\",\n  input: \"input\",\n  contentContainer: \"content-container\",\n  contentAnimation: \"content-animation\",\n  content: \"content\",\n  contentHidden: \"content--hidden\",\n  floatingUIContainer: \"floating-ui-container\",\n  floatingUIContainerActive: \"floating-ui-container--active\",\n  screenReadersOnly: \"screen-readers-only\"\n}, q = {\n  validationMessage: \"autocompleteValidationMessage\"\n}, W = \"calcite-autocomplete-item-group\", K = \"calcite-autocomplete-item\";\nclass j extends $ {\n  // #endregion\n  // #region Lifecycle\n  constructor() {\n    super(), this.guid = M(), this.attributeWatch = C([\"autofocus\", \"enterkeyhint\", \"inputmode\"], this.handleGlobalAttributesChanged), this.inputId = `autocomplete-input-${this.guid}`, this.listId = `autocomplete-list-${this.guid}`, this.messages = L(), this.transitionProp = \"opacity\", this.activeDescendant = \"\", this.activeIndex = -1, this.hasContentBottom = !1, this.hasContentTop = !1, this.items = [], this.groups = [], this.alignment = \"start\", this.disabled = !1, this.iconFlipRtl = !1, this.loading = !1, this.open = !1, this.overlayPositioning = \"absolute\", this.placement = f, this.readOnly = !1, this.required = !1, this.scale = \"m\", this.status = \"idle\", this.validity = {\n      valid: !1,\n      badInput: !1,\n      customError: !1,\n      patternMismatch: !1,\n      rangeOverflow: !1,\n      rangeUnderflow: !1,\n      stepMismatch: !1,\n      tooLong: !1,\n      tooShort: !1,\n      typeMismatch: !1,\n      valueMissing: !1\n    }, this.value = \"\", this.calciteAutocompleteBeforeClose = c({ cancelable: !1 }), this.calciteAutocompleteBeforeOpen = c({ cancelable: !1 }), this.calciteAutocompleteChange = c({ cancelable: !1 }), this.calciteAutocompleteClose = c({ cancelable: !1 }), this.calciteAutocompleteOpen = c({ cancelable: !1 }), this.calciteAutocompleteTextChange = c({ cancelable: !1 }), this.calciteAutocompleteTextInput = c({ cancelable: !1 }), this.mutationObserver = v(\"mutation\", () => this.getAllItemsDebounced()), this.resizeObserver = v(\"resize\", () => {\n      this.setFloatingElSize();\n    }), this.getAllItemsDebounced = k(this.getAllItems, 0), this.listenOn(document, \"click\", this.documentClickHandler), this.listen(\"calciteInternalAutocompleteItemSelect\", this.handleInternalAutocompleteItemSelect);\n  }\n  static {\n    this.properties = { activeDescendant: 16, activeIndex: 16, hasContentBottom: 16, hasContentTop: 16, items: 16, groups: 16, isOpen: 16, enabledItems: 16, alignment: 3, autocomplete: 0, disabled: 7, flipPlacements: 0, form: 3, icon: [3, { converter: m }], iconFlipRtl: 7, inputValue: 1, label: 1, loading: 7, maxLength: 11, messageOverrides: 0, minLength: 11, name: 3, open: 7, overlayPositioning: 3, pattern: 1, placeholder: 1, placement: 3, prefixText: 1, readOnly: 7, required: 7, scale: 3, status: 3, suffixText: 1, validationIcon: [3, { converter: m }], validationMessage: 1, validity: 0, value: 1 };\n  }\n  static {\n    this.styles = G;\n  }\n  get isOpen() {\n    return this.open && (this.hasContentTop || this.hasContentBottom || this.items.length > 0);\n  }\n  get enabledItems() {\n    return this.items.filter((t) => !t.disabled);\n  }\n  // #endregion\n  // #region Public Methods\n  /**\n   * Updates the position of the component.\n   *\n   * @param delayed - `true` if the placement should be updated after the component is finished rendering.\n   * @returns {Promise<void>}\n   */\n  async reposition(t = !1) {\n    const { floatingEl: e, referenceEl: o, placement: i, overlayPositioning: n, flipPlacements: a } = this;\n    return T(this, {\n      floatingEl: e,\n      referenceEl: o,\n      overlayPositioning: n,\n      placement: i,\n      flipPlacements: a,\n      type: \"menu\"\n    }, t);\n  }\n  /**\n   * Scrolls the component's content to a specified set of coordinates.\n   *\n   * @example\n   * myAutocomplete.scrollContentTo({\n   *   left: 0, // Specifies the number of pixels along the X axis to scroll the window or element.\n   *   top: 0, // Specifies the number of pixels along the Y axis to scroll the window or element\n   *   behavior: \"auto\" // Specifies whether the scrolling should animate smoothly (smooth), or happen instantly in a single jump (auto, the default value).\n   * });\n   * @param options - allows specific coordinates to be defined.\n   * @returns - promise that resolves once the content is scrolled to.\n   */\n  async scrollContentTo(t) {\n    this.transitionEl?.scrollTo(t);\n  }\n  /**\n   * Selects the text of the component's `value`.\n   *\n   * @returns {Promise<void>}\n   */\n  async selectText() {\n    return this.referenceEl.selectText();\n  }\n  /**\n   * Sets focus on the component's first focusable element.\n   *\n   * @returns {Promise<void>}\n   */\n  async setFocus() {\n    return this.referenceEl.setFocus();\n  }\n  connectedCallback() {\n    super.connectedCallback(), this.mutationObserver?.observe(this.el, { childList: !0, subtree: !0 }), F(this), z(this), this.defaultInputValue = this.inputValue || \"\", this.getAllItemsDebounced(), p(this);\n  }\n  async load() {\n    this.getAllItemsDebounced();\n  }\n  willUpdate(t) {\n    t.has(\"disabled\") && (this.hasUpdated || this.disabled !== !1) && this.handleDisabledChange(this.disabled), t.has(\"flipPlacements\") && this.reposition(!0), t.has(\"open\") && (this.hasUpdated || this.open !== !1) && this.openHandler(), t.has(\"overlayPositioning\") && (this.hasUpdated || this.overlayPositioning !== \"absolute\") && this.reposition(!0), t.has(\"placement\") && (this.hasUpdated || this.placement !== f) && this.reposition(!0);\n    let e = !1;\n    t.has(\"inputValue\") && (this.hasUpdated || this.inputValue) && (this.inputValueMatchPattern = this.inputValue && new RegExp(`(${A(this.inputValue)})`, \"i\"), this.updateItems(), this.updateGroups(), e = !0), !e && t.has(\"scale\") && (this.hasUpdated || this.scale !== \"m\") && (this.updateItems(), this.updateGroups(), e = !0), !e && t.has(\"activeIndex\") && (this.hasUpdated || this.activeIndex !== -1) && this.updateItems();\n  }\n  updated() {\n    w(this);\n  }\n  loaded() {\n    V(this, this.value || \"\"), this.defaultInputValue = this.inputValue || \"\", p(this);\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback(), this.mutationObserver?.disconnect(), this.resizeObserver?.disconnect(), D(this), H(this), E(this);\n  }\n  // #endregion\n  // #region Private Methods\n  setFloatingElSize() {\n    const { referenceEl: t, floatingEl: e } = this;\n    !t || !e || (e.style.inlineSize = `${t.clientWidth}px`);\n  }\n  handleGlobalAttributesChanged() {\n    this.requestUpdate();\n  }\n  handleDisabledChange(t) {\n    t || (this.open = !1);\n  }\n  openHandler() {\n    if (S(this), this.open || (this.activeIndex = -1), this.disabled) {\n      this.open = !1;\n      return;\n    }\n    this.setFloatingElSize(), this.reposition(!0);\n  }\n  async documentClickHandler(t) {\n    this.disabled || t.composedPath().includes(this.el) || (this.open = !1);\n  }\n  async handleInternalAutocompleteItemSelect(t) {\n    this.value = t.target.value, t.stopPropagation(), this.emitChange(), await this.setFocus(), this.open = !1;\n  }\n  onLabelClick() {\n    this.setFocus();\n  }\n  onFormReset() {\n    this.inputValue = this.defaultInputValue;\n  }\n  onBeforeOpen() {\n    this.calciteAutocompleteBeforeOpen.emit();\n  }\n  onOpen() {\n    this.calciteAutocompleteOpen.emit();\n  }\n  onBeforeClose() {\n    this.calciteAutocompleteBeforeClose.emit();\n  }\n  onClose() {\n    this.calciteAutocompleteClose.emit();\n  }\n  emitChange() {\n    this.calciteAutocompleteChange.emit();\n  }\n  updateGroups() {\n    this.groups.forEach((t, e, o) => {\n      t.scale = this.scale, e === 0 && (t.disableSpacing = !0);\n      const i = o[e + 1];\n      i && (i.disableSpacing = t.children.length === 0);\n    });\n  }\n  updateItems() {\n    let t = null;\n    this.items.forEach((e) => {\n      e.scale = this.scale, e.inputValueMatchPattern = this.inputValueMatchPattern;\n    }), this.enabledItems.forEach((e, o) => {\n      const i = o === this.activeIndex;\n      i && (t = e.guid), e.active = i;\n    }), this.activeDescendant = t;\n  }\n  handleInputFocus() {\n    this.open = !0;\n  }\n  handleContentTopSlotChange(t) {\n    this.hasContentTop = b(t);\n  }\n  handleContentBottomSlotChange(t) {\n    this.hasContentBottom = b(t);\n  }\n  getAllItems() {\n    const { el: t } = this;\n    this.groups = Array.from(t.querySelectorAll(W)), this.items = Array.from(t.querySelectorAll(K)), this.updateItems(), this.updateGroups();\n  }\n  setReferenceEl(t) {\n    this.referenceEl = t, t && (this.resizeObserver?.observe(t), p(this));\n  }\n  keyDownHandler(t) {\n    const { defaultPrevented: e, key: o } = t;\n    if (e)\n      return;\n    const { open: i, activeIndex: n, enabledItems: a } = this, u = a.length && n > -1 ? a[n] : null;\n    switch (o) {\n      case \"Escape\":\n        i && (this.open = !1, t.preventDefault());\n        break;\n      case \"Tab\":\n        this.open = !1;\n        break;\n      case \"Enter\":\n        i && u ? (this.value = u.value, this.emitChange(), this.open = !1, t.preventDefault()) : t.defaultPrevented || P(this) && t.preventDefault();\n        break;\n      case \"ArrowDown\":\n        a.length && (this.open = !0, this.activeIndex = n !== -1 ? Math.min(n + 1, a.length - 1) : 0, this.scrollToActiveItem(), t.preventDefault());\n        break;\n      case \"ArrowUp\":\n        a.length && (this.open = !0, this.activeIndex = n !== -1 ? Math.max(n - 1, 0) : a.length - 1, this.scrollToActiveItem(), t.preventDefault());\n        break;\n      case \"Home\":\n        a.length && (this.open = !0, this.activeIndex = 0, this.scrollToActiveItem(), t.preventDefault());\n        break;\n      case \"End\":\n        a.length && (this.open = !0, this.activeIndex = a.length - 1, this.scrollToActiveItem(), t.preventDefault());\n        break;\n    }\n  }\n  scrollToActiveItem() {\n    this.enabledItems[this.activeIndex]?.scrollIntoView({ block: \"nearest\" });\n  }\n  changeHandler(t) {\n    t.stopPropagation(), this.inputValue = t.target.value, this.calciteAutocompleteTextChange.emit();\n  }\n  inputClickHandler(t) {\n    t.defaultPrevented || (this.open = !0);\n  }\n  inputHandler(t) {\n    t.stopPropagation(), this.inputValue = t.target.value, this.calciteAutocompleteTextInput.emit();\n  }\n  setFloatingEl(t) {\n    this.floatingEl = t, p(this);\n  }\n  setTransitionEl(t) {\n    t && (this.transitionEl = t);\n  }\n  // #endregion\n  // #region Rendering\n  render() {\n    const { disabled: t, listId: e, inputId: o, isOpen: i } = this, n = this.el.autofocus, a = this.el.enterKeyHint, u = this.el.inputMode;\n    return O({ disabled: t, children: d`<div class=${r(l.inputContainer)}><calcite-input .alignment=${this.alignment} aria-activedescendant=${this.activeDescendant ?? s} aria-controls=${e ?? s} aria-owns=${e ?? s} aria-autocomplete=list .ariaExpanded=${i} aria-haspopup=listbox .autocomplete=${this.autocomplete} .autofocus=${n} class=${r(l.input)} clearable .disabled=${t} enterkeyhint=${a ?? s} .form=${this.form} .icon=${this.icon ?? !0} .iconFlipRtl=${this.iconFlipRtl} id=${o ?? s} inputmode=${u ?? s} .label=${this.label} .loading=${this.loading} .maxLength=${this.maxLength} .messageOverrides=${this.messages} .minLength=${this.minLength} .name=${this.name} @click=${this.inputClickHandler} @keydown=${this.keyDownHandler} @calciteInputChange=${this.changeHandler} @calciteInputInput=${this.inputHandler} @calciteInternalInputFocus=${this.handleInputFocus} .pattern=${this.pattern} .placeholder=${this.placeholder} .prefixText=${this.prefixText} .readOnly=${this.readOnly} role=combobox .scale=${this.scale} .status=${this.status} .suffixText=${this.suffixText} type=search .value=${this.inputValue} ${h(this.setReferenceEl)}></calcite-input>${this.renderListBox()}<div class=${r({\n      [l.contentContainer]: !0,\n      [l.floatingUIContainer]: !0,\n      [l.floatingUIContainerActive]: i\n    })} ${h(this.setFloatingEl)}><div class=${r({\n      [l.contentAnimation]: !0,\n      [g.animation]: !0,\n      [g.animationActive]: i\n    })} ${h(this.setTransitionEl)}><div class=${r({ [l.content]: !0, [l.contentHidden]: !i })}><slot name=${x.contentTop} @slotchange=${this.handleContentTopSlotChange}></slot><slot aria-hidden=true></slot><slot name=${x.contentBottom} @slotchange=${this.handleContentBottomSlotChange}></slot></div></div></div></div>${B({ component: this })}${this.validationMessage && this.status === \"invalid\" ? U({ icon: this.validationIcon, id: q.validationMessage, message: this.validationMessage, scale: this.scale, status: this.status }) : null}` });\n  }\n  renderListBox() {\n    return d`<ul aria-labelledby=${this.inputId ?? s} class=${r(l.screenReadersOnly)} id=${this.listId ?? s} role=listbox tabindex=-1>${this.renderListBoxOptions()}</ul>`;\n  }\n  renderListBoxOptions() {\n    return y(this.items.filter((t) => !!(t.label || t.heading)), (t) => t.guid, (t) => d`<li .ariaDisabled=${t.disabled} .ariaLabel=${t.label} id=${t.guid ?? s} role=option tabindex=-1>${t.heading}${t.description}</li>`);\n  }\n}\nI(\"calcite-autocomplete\", j);\nexport {\n  j as Autocomplete\n};\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ChildPart, noChange} from '../lit-html.js';\nimport {directive, Directive, PartInfo, PartType} from '../directive.js';\nimport {\n  insertPart,\n  getCommittedValue,\n  removePart,\n  setCommittedValue,\n  setChildPartValue,\n} from '../directive-helpers.js';\n\nexport type KeyFn<T> = (item: T, index: number) => unknown;\nexport type ItemTemplate<T> = (item: T, index: number) => unknown;\n\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list: unknown[], start: number, end: number) => {\n  const map = new Map<unknown, number>();\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n  return map;\n};\n\nclass RepeatDirective extends Directive {\n  private _itemKeys?: unknown[];\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.CHILD) {\n      throw new Error('repeat() can only be used in text expressions');\n    }\n  }\n\n  private _getValuesAndKeys<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    let keyFn: KeyFn<T> | undefined;\n    if (template === undefined) {\n      template = keyFnOrTemplate;\n    } else if (keyFnOrTemplate !== undefined) {\n      keyFn = keyFnOrTemplate as KeyFn<T>;\n    }\n    const keys = [];\n    const values = [];\n    let index = 0;\n    for (const item of items) {\n      keys[index] = keyFn ? keyFn(item, index) : index;\n      values[index] = template!(item, index);\n      index++;\n    }\n    return {\n      values,\n      keys,\n    };\n  }\n\n  render<T>(items: Iterable<T>, template: ItemTemplate<T>): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;\n  }\n\n  override update<T>(\n    containerPart: ChildPart,\n    [items, keyFnOrTemplate, template]: [\n      Iterable<T>,\n      KeyFn<T> | ItemTemplate<T>,\n      ItemTemplate<T>,\n    ]\n  ) {\n    // Old part & key lists are retrieved from the last update (which may\n    // be primed by hydration)\n    const oldParts = getCommittedValue(\n      containerPart\n    ) as Array<ChildPart | null>;\n    const {values: newValues, keys: newKeys} = this._getValuesAndKeys(\n      items,\n      keyFnOrTemplate,\n      template\n    );\n\n    // We check that oldParts, the committed value, is an Array as an\n    // indicator that the previous value came from a repeat() call. If\n    // oldParts is not an Array then this is the first render and we return\n    // an array for lit-html's array handling to render, and remember the\n    // keys.\n    if (!Array.isArray(oldParts)) {\n      this._itemKeys = newKeys;\n      return newValues;\n    }\n\n    // In SSR hydration it's possible for oldParts to be an array but for us\n    // to not have item keys because the update() hasn't run yet. We set the\n    // keys to an empty array. This will cause all oldKey/newKey comparisons\n    // to fail and execution to fall to the last nested brach below which\n    // reuses the oldPart.\n    const oldKeys = (this._itemKeys ??= []);\n\n    // New part list will be built up as we go (either reused from\n    // old parts or created for new keys in this update). This is\n    // saved in the above cache at the end of the update.\n    const newParts: ChildPart[] = [];\n\n    // Maps from key to index for current and previous update; these\n    // are generated lazily only when needed as a performance\n    // optimization, since they are only required for multiple\n    // non-contiguous changes in the list, which are less common.\n    let newKeyToIndexMap!: Map<unknown, number>;\n    let oldKeyToIndexMap!: Map<unknown, number>;\n\n    // Head and tail pointers to old parts and new values\n    let oldHead = 0;\n    let oldTail = oldParts.length - 1;\n    let newHead = 0;\n    let newTail = newValues.length - 1;\n\n    // Overview of O(n) reconciliation algorithm (general approach\n    // based on ideas found in ivi, vue, snabbdom, etc.):\n    //\n    // * We start with the list of old parts and new values (and\n    //   arrays of their respective keys), head/tail pointers into\n    //   each, and we build up the new list of parts by updating\n    //   (and when needed, moving) old parts or creating new ones.\n    //   The initial scenario might look like this (for brevity of\n    //   the diagrams, the numbers in the array reflect keys\n    //   associated with the old parts or new values, although keys\n    //   and parts/values are actually stored in parallel arrays\n    //   indexed using the same head/tail pointers):\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n    //                                      item order\n    //      newHead ^                 ^ newTail\n    //\n    // * Iterate old & new lists from both sides, updating,\n    //   swapping, or removing parts at the head/tail locations\n    //   until neither head nor tail can move.\n    //\n    // * Example below: keys at head pointers match, so update old\n    //   part 0 in-place (no need to move it) and record part 0 in\n    //   the `newParts` list. The last thing we do is advance the\n    //   `oldHead` and `newHead` pointers (will be reflected in the\n    //   next diagram).\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //      newHead ^                 ^ newTail\n    //\n    // * Example below: head pointers don't match, but tail\n    //   pointers do, so update part 6 in place (no need to move\n    //   it), and record part 6 in the `newParts` list. Last,\n    //   advance the `oldTail` and `oldHead` pointers.\n    //\n    //         oldHead v              v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\n    //                                      & newTail\n    //         newHead ^              ^ newTail\n    //\n    // * If neither head nor tail match; next check if one of the\n    //   old head/tail items was removed. We first need to generate\n    //   the reverse map of new keys to index (`newKeyToIndexMap`),\n    //   which is done once lazily as a performance optimization,\n    //   since we only hit this case if multiple non-contiguous\n    //   changes were made. Note that for contiguous removal\n    //   anywhere in the list, the head and tails would advance\n    //   from either end and pass each other before we get to this\n    //   case and removals would be handled in the final while loop\n    //   without needing to generate the map.\n    //\n    // * Example below: The key at `oldTail` was removed (no longer\n    //   in the `newKeyToIndexMap`), so remove that part from the\n    //   DOM and advance just the `oldTail` pointer.\n    //\n    //         oldHead v           v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\n    //         newHead ^           ^ newTail\n    //\n    // * Once head and tail cannot move, any mismatches are due to\n    //   either new or moved items; if a new key is in the previous\n    //   \"old key to old index\" map, move the old part to the new\n    //   location, otherwise create and insert a new part. Note\n    //   that when moving an old part we null its position in the\n    //   oldParts array if it lies between the head and tail so we\n    //   know to skip it when the pointers get there.\n    //\n    // * Example below: neither head nor tail match, and neither\n    //   were removed; so find the `newHead` key in the\n    //   `oldKeyToIndexMap`, and move that old part's DOM into the\n    //   next head position (before `oldParts[oldHead]`). Last,\n    //   null the part in the `oldPart` array since it was\n    //   somewhere in the remaining oldParts still to be scanned\n    //   (between the head and tail pointers) so that we know to\n    //   skip that old part on future iterations.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\n    //                                      newHead\n    //         newHead ^           ^ newTail\n    //\n    // * Note that for moves/insertions like the one above, a part\n    //   inserted at the head pointer is inserted before the\n    //   current `oldParts[oldHead]`, and a part inserted at the\n    //   tail pointer is inserted before `newParts[newTail+1]`. The\n    //   seeming asymmetry lies in the fact that new parts are\n    //   moved into place outside in, so to the right of the head\n    //   pointer are old parts, and to the right of the tail\n    //   pointer are new parts.\n    //\n    // * We always restart back from the top of the algorithm,\n    //   allowing matching and simple updates in place to\n    //   continue...\n    //\n    // * Example below: the head pointers once again match, so\n    //   simply update part 1 and record it in the `newParts`\n    //   array.  Last, advance both head pointers.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //            newHead ^        ^ newTail\n    //\n    // * As mentioned above, items that were moved as a result of\n    //   being stuck (the final else clause in the code below) are\n    //   marked with null, so we always advance old pointers over\n    //   these so we're comparing the next actual old value on\n    //   either end.\n    //\n    // * Example below: `oldHead` is null (already placed in\n    //   newParts), so advance `oldHead`.\n    //\n    //            oldHead v     v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\n    //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //               newHead ^     ^ newTail\n    //\n    // * Note it's not critical to mark old parts as null when they\n    //   are moved from head to tail or tail to head, since they\n    //   will be outside the pointer range and never visited again.\n    //\n    // * Example below: Here the old tail key matches the new head\n    //   key, so the part at the `oldTail` position and move its\n    //   DOM to the new head position (before `oldParts[oldHead]`).\n    //   Last, advance `oldTail` and `newHead` pointers.\n    //\n    //               oldHead v  v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\n    //                                     advance oldTail & newHead\n    //               newHead ^     ^ newTail\n    //\n    // * Example below: Old and new head keys match, so update the\n    //   old head part in place, and advance the `oldHead` and\n    //   `newHead` pointers.\n    //\n    //               oldHead v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\n    //                                      newHead\n    //                  newHead ^  ^ newTail\n    //\n    // * Once the new or old pointers move past each other then all\n    //   we have left is additions (if old list exhausted) or\n    //   removals (if new list exhausted). Those are handled in the\n    //   final while loops at the end.\n    //\n    // * Example below: `oldHead` exceeded `oldTail`, so we're done\n    //   with the main loop.  Create the remaining part and insert\n    //   it at the new head position, and the update is complete.\n    //\n    //                   (oldHead > oldTail)\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //                     newHead ^ newTail\n    //\n    // * Note that the order of the if/else clauses is not\n    //   important to the algorithm, as long as the null checks\n    //   come first (to ensure we're always working on valid old\n    //   parts) and that the final else clause comes last (since\n    //   that's where the expensive moves occur). The order of\n    //   remaining clauses is just a simple guess at which cases\n    //   will be most common.\n    //\n    // * Note, we could calculate the longest\n    //   increasing subsequence (LIS) of old items in new position,\n    //   and only move those not in the LIS set. However that costs\n    //   O(nlogn) time and adds a bit more code, and only helps\n    //   make rare types of mutations require fewer moves. The\n    //   above handles removes, adds, reversal, swaps, and single\n    //   moves of contiguous items in linear time, in the minimum\n    //   number of moves. As the number of multiple moves where LIS\n    //   might help approaches a random shuffle, the LIS\n    //   optimization becomes less helpful, so it seems not worth\n    //   the code at this point. Could reconsider if a compelling\n    //   case arises.\n\n    while (oldHead <= oldTail && newHead <= newTail) {\n      if (oldParts[oldHead] === null) {\n        // `null` means old part at head has already been used\n        // below; skip\n        oldHead++;\n      } else if (oldParts[oldTail] === null) {\n        // `null` means old part at tail has already been used\n        // below; skip\n        oldTail--;\n      } else if (oldKeys[oldHead] === newKeys[newHead]) {\n        // Old head matches new head; update in place\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newHead]\n        );\n        oldHead++;\n        newHead++;\n      } else if (oldKeys[oldTail] === newKeys[newTail]) {\n        // Old tail matches new tail; update in place\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newTail]\n        );\n        oldTail--;\n        newTail--;\n      } else if (oldKeys[oldHead] === newKeys[newTail]) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newTail]\n        );\n        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]!);\n        oldHead++;\n        newTail--;\n      } else if (oldKeys[oldTail] === newKeys[newHead]) {\n        // Old tail matches new head; update and move to new head\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newHead]\n        );\n        insertPart(containerPart, oldParts[oldHead]!, oldParts[oldTail]!);\n        oldTail--;\n        newHead++;\n      } else {\n        if (newKeyToIndexMap === undefined) {\n          // Lazily generate key-to-index maps, used for removals &\n          // moves below\n          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n        }\n        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n          // Old head is no longer in new list; remove\n          removePart(oldParts[oldHead]!);\n          oldHead++;\n        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n          // Old tail is no longer in new list; remove\n          removePart(oldParts[oldTail]!);\n          oldTail--;\n        } else {\n          // Any mismatches at this point are due to additions or\n          // moves; see if we have an old part we can reuse and move\n          // into place\n          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n          const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n          if (oldPart === null) {\n            // No old part for this value; create a new one and\n            // insert it\n            const newPart = insertPart(containerPart, oldParts[oldHead]!);\n            setChildPartValue(newPart, newValues[newHead]);\n            newParts[newHead] = newPart;\n          } else {\n            // Reuse old part\n            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);\n            insertPart(containerPart, oldParts[oldHead]!, oldPart);\n            // This marks the old part as having been used, so that\n            // it will be skipped in the first two checks above\n            oldParts[oldIndex as number] = null;\n          }\n          newHead++;\n        }\n      }\n    }\n    // Add parts for any remaining new values\n    while (newHead <= newTail) {\n      // For all remaining additions, we insert before last new\n      // tail, since old pointers are no longer valid\n      const newPart = insertPart(containerPart, newParts[newTail + 1]);\n      setChildPartValue(newPart, newValues[newHead]);\n      newParts[newHead++] = newPart;\n    }\n    // Remove any remaining unused old parts\n    while (oldHead <= oldTail) {\n      const oldPart = oldParts[oldHead++];\n      if (oldPart !== null) {\n        removePart(oldPart);\n      }\n    }\n\n    // Save order of new parts for next round\n    this._itemKeys = newKeys;\n    // Directly set part value, bypassing it's dirty-checking\n    setCommittedValue(containerPart, newParts);\n    return noChange;\n  }\n}\n\nexport interface RepeatDirectiveFn {\n  <T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ): unknown;\n  <T>(items: Iterable<T>, template: ItemTemplate<T>): unknown;\n  <T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): unknown;\n}\n\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * and removals.\n *\n * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.\n *\n * ```js\n * html`\n *   <ol>\n *     ${repeat(this.items, (item) => item.id, (item, index) => {\n *       return html`<li>${index}: ${item.name}</li>`;\n *     })}\n *   </ol>\n * `\n * ```\n *\n * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat = directive(RepeatDirective) as RepeatDirectiveFn;\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {RepeatDirective};\n"],"names":["G","R","x","l","q","j","$","constructor","super","this","guid","M","attributeWatch","C","handleGlobalAttributesChanged","inputId","listId","messages","L","transitionProp","activeDescendant","activeIndex","hasContentBottom","hasContentTop","items","groups","alignment","disabled","iconFlipRtl","loading","open","overlayPositioning","placement","f","readOnly","required","scale","status","validity","valid","badInput","customError","patternMismatch","rangeOverflow","rangeUnderflow","stepMismatch","tooLong","tooShort","typeMismatch","valueMissing","value","calciteAutocompleteBeforeClose","c","cancelable","calciteAutocompleteBeforeOpen","calciteAutocompleteChange","calciteAutocompleteClose","calciteAutocompleteOpen","calciteAutocompleteTextChange","calciteAutocompleteTextInput","mutationObserver","v","getAllItemsDebounced","resizeObserver","setFloatingElSize","k","getAllItems","listenOn","document","documentClickHandler","listen","handleInternalAutocompleteItemSelect","properties","isOpen","enabledItems","autocomplete","flipPlacements","form","icon","converter","m","inputValue","label","maxLength","messageOverrides","minLength","name","pattern","placeholder","prefixText","suffixText","validationIcon","validationMessage","styles","length","filter","t","reposition","arguments","undefined","floatingEl","e","referenceEl","o","i","n","a","T","type","scrollContentTo","transitionEl","scrollTo","selectText","setFocus","connectedCallback","observe","el","childList","subtree","F","z","defaultInputValue","p","load","willUpdate","has","hasUpdated","handleDisabledChange","openHandler","inputValueMatchPattern","RegExp","A","updateItems","updateGroups","updated","w","loaded","V","disconnectedCallback","disconnect","D","H","E","style","inlineSize","clientWidth","requestUpdate","S","composedPath","includes","target","stopPropagation","emitChange","onLabelClick","onFormReset","onBeforeOpen","emit","onOpen","onBeforeClose","onClose","forEach","disableSpacing","children","active","handleInputFocus","handleContentTopSlotChange","b","handleContentBottomSlotChange","Array","from","querySelectorAll","setReferenceEl","keyDownHandler","defaultPrevented","key","u","preventDefault","P","Math","min","scrollToActiveItem","max","scrollIntoView","block","changeHandler","inputClickHandler","inputHandler","setFloatingEl","setTransitionEl","render","autofocus","enterKeyHint","inputMode","O","d","r","s","h","renderListBox","g","animation","animationActive","B","component","U","id","message","renderListBoxOptions","y","heading","description","I","generateMap","Map","set","CHILD","Error","dt","values","keys","update","_ref","isArray","ut","get"],"sourceRoot":""}